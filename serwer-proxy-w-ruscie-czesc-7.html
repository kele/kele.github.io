<!DOCTYPE html>
<html lang="pl">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">


        <title>Serwer proxy w Ruscie (część 7)</title>

            <link href="http://kele.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="kele.github.io Full Atom Feed" />
            <link href="http://kele.github.io/feeds/rust.atom.xml" type="application/atom+xml" rel="alternate" title="kele.github.io Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="./theme/css/bootstrap.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="./theme/css/clean-blog.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="./theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="rust" />


	                <meta property="og:locale" content="pl_PL.utf8">
		<meta property="og:site_name" content="kele.github.io">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="./serwer-proxy-w-ruscie-czesc-7.html">
	<meta property="og:title" content="Serwer proxy w Ruscie (część 7)">
	<meta property="og:description" content="">
	<meta property="og:image" content="./">
	<meta property="article:published_time" content="2017-07-02 00:00:00+02:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="./">kele.github.io</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">

                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('./theme/images/header.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Serwer proxy w Ruscie (część 7)</h1>
                        <span class="meta">nie 02 lipiec 2017</span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p>Kod dostępny <a href="https://github.com/kele/foxy/tree/part7">tutaj</a>.</p>
<h1>Czy zaimplementuję protokół HTTP (<a href="https://tools.ietf.org/html/rfc7230">RFC 7230</a>)?</h1>
<p>Nie.</p>
<p>W każdym projekcie (nie tylko programistycznym) jest taki moment kiedy, żeby coś
było skończone, trzeba się sporo napracować. Czasem taka praca sprawia, że
uczymy się dużo nowych rzeczy. Z mojego doświadczenia wynika jednak, że nie
zawsze tak jest i całkiem nieźle działa tutaj zasada <a href="https://pl.wikipedia.org/wiki/Zasada_Pareta">80/20
(Pareto)</a>.</p>
<p>W ramach <strong>foxy</strong> mógłbym skupić się na własnej implementacji całego protokołu
HTTP, ale nie sądzę, żebym nauczył się dużo więcej niż do tej pory. A na pewno
nie w takim tempie jak teraz. Samo ustalenie długości ciała zapytania (message
body length) jest w <a href="https://tools.ietf.org/html/rfc7230">RFC 7230</a> opisane tak:</p>
<div class="highlight"><pre><span></span>1.  Any response to a HEAD request and any response with a 1xx
    (Informational), 204 (No Content), or 304 (Not Modified) status
    code is always terminated by the first empty line after the
    header fields, regardless of the header fields present in the
    message, and thus cannot contain a message body.

2.  Any 2xx (Successful) response to a CONNECT request implies that
    the connection will become a tunnel immediately after the empty
    line that concludes the header fields.  A client MUST ignore any
    Content-Length or Transfer-Encoding header fields received in
    such a message.

3.  If a Transfer-Encoding header field is present and the chunked
    transfer coding (Section 4.1) is the final encoding, the message
    body length is determined by reading and decoding the chunked
    data until the transfer coding indicates the data is complete.

    If a Transfer-Encoding header field is present in a response and
    the chunked transfer coding is not the final encoding, the
    message body length is determined by reading the connection until
    it is closed by the server.  If a Transfer-Encoding header field
    is present in a request and the chunked transfer coding is not
    the final encoding, the message body length cannot be determined
    reliably; the server MUST respond with the 400 (Bad Request)
    status code and then close the connection.

    If a message is received with both a Transfer-Encoding and a
    Content-Length header field, the Transfer-Encoding overrides the
    Content-Length.  Such a message might indicate an attempt to
    perform request smuggling (Section 9.5) or response splitting
    (Section 9.4) and ought to be handled as an error.  A sender MUST
    remove the received Content-Length field prior to forwarding such
    a message downstream.

4.  If a message is received without Transfer-Encoding and with
    either multiple Content-Length header fields having differing
    field-values or a single Content-Length header field having an
    invalid value, then the message framing is invalid and the
    recipient MUST treat it as an unrecoverable error.  If this is a
    request message, the server MUST respond with a 400 (Bad Request)
    status code and then close the connection.  If this is a response
    message received by a proxy, the proxy MUST close the connection
    to the server, discard the received response, and send a 502 (Bad
    Gateway) response to the client.  If this is a response message
    received by a user agent, the user agent MUST close the
    connection to the server and discard the received response.

5.  If a valid Content-Length header field is present without
    Transfer-Encoding, its decimal value defines the expected message
    body length in octets.  If the sender closes the connection or
    the recipient times out before the indicated number of octets are
    received, the recipient MUST consider the message to be
    incomplete and close the connection.

6.  If this is a request message and none of the above are true, then
    the message body length is zero (no message body is present).

7.  Otherwise, this is a response message without a declared message
    body length, so the message body length is determined by the
    number of octets received prior to the server closing the
    connection.
</pre></div>


<p>Oczywiście, mógłbym to zaimplementować i pewnie napisałbym wtedy trochę kodu.
Ale czy nauczyłbym się wtedy czegokolwiek o Ruscie? Nie sądzę. Czy posunąłbym
projekt do przodu bardziej niż gdybym skorzystał z gotowej biblioteki do obsługi
HTTP(S)? Też nie.</p>
<p>Doszedłem do takich wniosków w ciągu ostatnich kilku dni i zdecydowałem, że ten
wpis będzie wpisem zamykającym rozdział, w którym piszemy własny moduł do
obsługi protokołu HTTP. <strong>Seria będzie kontynuowana</strong>, prawdopodobnie przy
użyciu wspomnianej już kiedyś paczki
<a href="https://github.com/hyperium/hyper"><strong>hyper</strong></a>. Skupiać się będę jednak na tym,
jak przetwarzać żądania na nieco wyższym poziomie abstrakcji niż dotychczas.</p>
<h2>Dla zainteresowanych kodem</h2>
<p>Na początku postu jest link do aktualnej wersji foxy, która dalej korzysta z
własnego modułu do obsługi HTTP. W miarę interesującym fragmentem jest tam
implementacja tunelu, gdzie używam wątków i dzielenia zmiennych między nimi przy
pomocy <code>std::sync::Arc</code>. Niemniej jednak, wydaje mi się, że korzystając z
<strong>hyper</strong> też będę musiał prędzej czy później samemu tworzyć wątki, więc omówię
ten temat kiedy zajdzie taka potrzeba.</p>
<h1>Pozostałe części</h1>
<ul>
<li>następny post (część 8) w przygotowaniu</li>
<li><a href="serwer-proxy-w-ruscie-czesc-6.html">poprzedni post (część 6) (działający serwer echo)</a></li>
</ul>
    </article>

    <hr>
        <div class="comments">
            <div id="disqus_thread"></div>
            <script>
                var disqus_config = function () {
                    this.page.url = 'http://kele.github.io/' + 'serwer-proxy-w-ruscie-czesc-7.html';
                    this.page.identifier = 'disqus-' + 'serwer-proxy-w-ruscie-czesc-7.html';
                };
                (function() {  // DON'T EDIT BELOW THIS LINE
                    var d = document, s = d.createElement('script');
                    s.src = 'https://kele-github-io.disqus.com/embed.js';
                    s.setAttribute('data-timestamp', +new Date());
                    (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
        </div>
            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="./theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="./theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="./theme/js/clean-blog.min.js"></script>


</body>

</html>