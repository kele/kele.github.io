<!DOCTYPE html>
<html lang="en">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">


        <title>Serwer proxy w Ruscie (część 6)</title>

            <link href="http://kele.codes/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="kele.codes Full Atom Feed" />
            <link href="http://kele.codes/feeds/{slug}.atom.xml" type="application/atom+xml" rel="alternate" title="kele.codes Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="./theme/css/bootstrap.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="./theme/css/clean-blog.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="./theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="rust" />
        <meta name="tags" contents="foxy" />
        <meta name="tags" contents="error handling" />
        <meta name="tags" contents="macros" />


	                <meta property="og:locale" content="en_US.UTF-8">
		<meta property="og:site_name" content="kele.codes">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="./serwer-proxy-w-ruscie-czesc-6-pl.html">
	<meta property="og:title" content="Serwer proxy w Ruscie (część 6)">
	<meta property="og:description" content="">
	<meta property="og:image" content="./">
	<meta property="article:published_time" content="2017-06-19 00:00:00+02:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="./">kele.codes</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">

                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('./theme/images/header.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Serwer proxy w Ruscie (część 6)</h1>
                        <span class="meta">Mon 19 June 2017</span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p>Kod dostępny <a href="https://github.com/kele/foxy/tree/part6">tutaj</a>.</p>
<h2>Nowa implementacja <code>HttpStream::get_request</code></h2>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nb">Option</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">Request</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="n">input</span><span class="p">.</span><span class="n">ends_with</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n\r\n</span><span class="s">&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tcp_bytes</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">UnexpectedEof</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)),</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="o">?</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">char</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="n">input</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RequestHeader</span>::<span class="n">parse</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">lines</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"> </span><span class="c1">// TODO: read the body</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">Request</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">header</span>: <span class="nc">header</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">body</span>: <span class="nc">body</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">}))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<h3><code>ends_with()</code></h3>
<p>Pierwszą istotną zmianą jest użycie metody <code>ends_with()</code>, która sprawdza czy
napis kończy się danym wzorcem (w tym przypadku są to po prostu dwie sekwencje
CRLF, czyli nowe linie w kodowaniu DOS).</p>
<h3><code>RequestHeader::parse()</code></h3>
<p>Wcześniej zapisywaliśmy nagłówek w formie napisu. Teraz jego zawartość jest
odczytywana przy pomocy funkcji <code>parse()</code>.  Znak zapytania na końcu służy do
odpakowania wyniku i ewentualnej propagacji błędu.</p>
<h2>Moduł <code>header</code></h2>
<p>Nagłówek żądania HTTP ma formę:</p>
<div class="highlight"><pre><span></span><span class="nf">GET</span> <span class="nn">/hello.htm</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">User-Agent</span><span class="o">:</span> <span class="l">Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span>
<span class="na">Host</span><span class="o">:</span> <span class="l">www.tutorialspoint.com</span>
<span class="na">Accept-Language</span><span class="o">:</span> <span class="l">en-us</span>
<span class="na">Accept-Encoding</span><span class="o">:</span> <span class="l">gzip, deflate</span>
<span class="na">Connection</span><span class="o">:</span> <span class="l">Keep-Alive</span>
</pre></div>


<p>Składa się on z:</p>
<ul>
<li>jednej linii zawierającej rodzaj zapytania, URI oraz wersję protokołu,</li>
<li>kolejnych linii formatu <code>pole: wartość</code>,</li>
<li>"\r\n\r\n" (czyli dwa CRLF).</li>
</ul>
<p>Do przetwarzania nagłówków utworzymy sobie nowy moduł <code>header</code> w pliku
<code>http/header.rs</code>.</p>
<p>Zawierać on będzie (podobne do siebie) definicje nagłówka żądania
<code>RequestHeader</code> oraz zapytania <code>ResponseHeader</code>.</p>
<div class="highlight"><pre><span></span><span class="c1">// http/header.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">RequestHeader</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">method</span>: <span class="nc">RequestMethod</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">uri</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">protocol</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">fields</span>: <span class="nc">HashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p><code>RequestMethod</code> będzie typem <code>enum</code> zawierającym możliwe typy żądań HTTP. Na
razie interesować nas będzie wyłącznie <code>GET</code>.</p>
<div class="highlight"><pre><span></span><span class="cp">#[derive (Clone, Copy)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">RequestMethod</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Get</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// TODO: add more methods here</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Korzystamy z <code>enum</code>, ponieważ jest tylko kilka możliwych rodzajów zapytań HTTP
i chcielibyśmy móc o nich mówić bez każdorazowego porównywania napisów <code>"GET"</code>,
<code>"POST"</code> czy <code>"CONNECT"</code>. Drugim argumentem jest fakt, że w taki sposób
pomagamy kompilatorowi w wyłapywaniu błędów. Przykładowo, dla takiego kodu:</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Xyz</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Foo</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Bar</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Baz</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">code</span><span class="p">()</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">Xyz</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Xyz</span>::<span class="n">Foo</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">code</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Xyz</span>::<span class="n">Foo</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Foo&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">Xyz</span>::<span class="n">Bar</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Bar&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Ups! Zapomnieliśmy o implementacji dla Baz!</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>otrzymalibyśmy następujący błąd kompilacji:</p>
<div class="highlight"><pre><span></span>error<span class="o">[</span>E0004<span class="o">]</span>: non-exhaustive patterns: <span class="sb">`</span>Baz<span class="sb">`</span> not covered
  --<span class="p">&amp;</span>gt<span class="p">;</span> <span class="p">&amp;</span>lt<span class="p">;</span>anon<span class="p">&amp;</span>gt<span class="p">;</span>:12:15
   <span class="p">|</span>
<span class="m">12</span> <span class="p">|</span>         match code<span class="o">()</span> <span class="o">{</span>
   <span class="p">|</span>               ^^^^^^ pattern <span class="sb">`</span>Baz<span class="sb">`</span> not covered

error: aborting due to previous error
</pre></div>


<p>Dyrektywa <code>#[derive (Clone, Copy)]</code> jest tutaj instrukcją do kompilatora, która
każe mu zaimplementować cechy <code>Clone</code> i <code>Copy</code> (obie pozwalają na kopiowanie
obiektu, w nieco inny sposób, o tym kiedy indziej) dla typu <code>RequestMethod</code> na
podstawie jego składowych.  W tym przypadku, robimy to z dwóch powodów:</p>
<ul>
<li>wydaje się naturalnym, że taki typ powinien móc być łatwo kopiowany,</li>
<li>chcemy później w łatwy sposób zaimplementować cechę <code>Clone</code> dla żądania
  <code>Request</code>, którego <code>RequestMethod</code> jest składową.</li>
</ul>
<p>Dyrektywy <code>derive</code> są bardzo przydatne kiedy chcemy zaimplementować cechy, z
którymi spokojnie sobie poradzi kompilator (m.in. <code>Clone</code>, <code>Debug</code>). W tej
chwili nie wiem jeszcze jakie cechy można umieścić w tej dyrektywie, ale pewnie
niedługo się dowiem. :)</p>
<h3>Parsowanie nagłówka żądania HTTP</h3>
<div class="highlight"><pre><span></span><span class="c1">// http/header.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">RequestHeader</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">lines</span>: <span class="nc">Lines</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">Self</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">request_line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lines</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap_or_default</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">parts</span>: <span class="nb">Vec</span><span class="kp">&amp;</span><span class="nc">lt</span><span class="p">;</span><span class="n">_</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request_line</span><span class="p">.</span><span class="n">trim</span><span class="p">().</span><span class="n">split_whitespace</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">parts</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">err_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Request header should consist of three parts. Got: {:?}&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">request_line</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">err_msg</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">method</span><span class="p">,</span><span class="w"> </span><span class="n">uri</span><span class="p">,</span><span class="w"> </span><span class="n">protocol</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>

<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="s">&quot;GET&quot;</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">Self</span>::<span class="n">parse_get_header</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span><span class="w"> </span><span class="n">protocol</span><span class="p">,</span><span class="w"> </span><span class="n">lines</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">err_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Unsupported request method. Request line: {:?}&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">request_line</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">err_msg</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p><code>Lines</code> jest iteratorem po kolejnych liniach napisu. Iteratorów (czyli typów
implementujących cechę <code>std::iter::Iterator</code>) można używać m.in. w pętlach
<code>for</code>, pobierać z nich kolejne elementy przy pomocy metody <code>next()</code> oraz
dokonywać na nich wiele innych operacji, które zobaczymy później.</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">request_line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lines</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap_or_default</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>Tutaj właśnie odczytujemy pierwszą linię z obiektu <code>Lines</code>. <code>unwrap()</code> lub jego
inna forma są tutaj konieczne. W tym wypadku, zadowolimy się jeśli w przypadku
braku pierwszej linii wynikiem będzie pusty napis.</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">parts</span>: <span class="nb">Vec</span><span class="kp">&amp;</span><span class="nc">lt</span><span class="p">;</span><span class="n">_</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request_line</span><span class="p">.</span><span class="n">trim</span><span class="p">().</span><span class="n">split_whitespace</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>Odcinamy białe znaki z obu końców <code>request_line</code> przy pomocy <code>trim()</code>.
<code>split_whitespace()</code> dzieli nasz napis w miejscach w których są białe znaki, zaś
<code>collect()</code> zbiera wynik i zwraca go w formie tablicy <code>Vec</code>.</p>
<p>W tym wypadku podpowiedzieliśmy kompilatorowi, że <code>parts</code> będzie typu <code>Vec&lt;_&gt;</code>,
czyli zmienną będącą dynamiczna tablicą przechowującą obiekty jakiegoś (<code>_</code>)
typu. Jest to o tyle ważne, że <code>collect()</code> może zwrócić dowolny obiekt
spełniający cechę <code>FromIterator</code>. Kiedy już jednak podpowiemy, że chodzi nam o
<code>Vec</code>, to kompilator już będzie w stanie sam uzupełnić sobie brakującą lukę
<code>_</code>.</p>
<p>Jak widać, złożyliśmy tutaj po drodze kilka funkcji, <code>trim()</code>,
<code>split_whitespace()</code> oraz <code>collect()</code>. Takie właśnie złożenia są powszechną
praktyką w językach funkcyjnych, ale także i w Ruscie. Skracają one kod, a
często pozwalają na dokonanie optymalizacji (kompilator od razu widzi, że nie
potrzebujemy pośrednich wyników, bo nie zapisujemy ich nigdzie).</p>
<p>Co ciekawe, zarówno <code>trim()</code> jak i <code>split_whitespace()</code> nie dokonują żadnego
kopiowania napisów, po prostu zwracając obiekty typu <code>&amp;str</code> (czyli kawałki
zaalokowanego już gdzieś napisu).</p>
<div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="n">parts</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">err_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Request header should consist of three parts. Got: {:?}&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">request_line</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">err_msg</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">method</span><span class="p">,</span><span class="w"> </span><span class="n">uri</span><span class="p">,</span><span class="w"> </span><span class="n">protocol</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;GET&quot;</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">RequestMethod</span>::<span class="n">Get</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">err_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Unsupported request method. Request line: {:?}&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="n">request_line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">err_msg</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>


<p>Poprawny nagłówek żądania HTTP powinien składać się z trzech części i tutaj
właśnie sprawdzamy czy tak faktycznie jest. Jeśli tak, przypisujemy je do
zmiennych o odpowiednich nazwach.</p>
<div class="highlight"><pre><span></span><span class="c1">// http/header.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">RequestHeader</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">lines</span>: <span class="nc">Lines</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">Self</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">RequestHeader</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">               </span><span class="n">method</span>: <span class="nc">method</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">uri</span>: <span class="nc">uri</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"></span>
<span class="w">               </span><span class="n">protocol</span>: <span class="nc">protocol</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"></span>
<span class="w">               </span><span class="n">fields</span>: <span class="nc">parse_fields</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">?</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Tak jak wcześniej wspomniałem, <code>trim()</code> oraz <code>split_whitespace()</code> nie kopiują
napisów, w związku z tym robimy to sami przy pomocy metody <code>to_owned()</code> typu
<code>&amp;str</code>, która po prostu zwraca <code>String</code>. <code>parse_fields</code> jest funkcją, która
zajmie się odczytywaniem pól nagłówka.</p>
<h3><code>parse_fields</code></h3>
<div class="highlight"><pre><span></span><span class="c1">// http/header.rs</span>

<span class="k">fn</span> <span class="nf">parse_fields</span><span class="p">(</span><span class="n">lines</span>: <span class="nc">Lines</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">HashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">lines</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">parts</span>: <span class="nb">Vec</span><span class="kp">&amp;</span><span class="nc">lt</span><span class="p">;</span><span class="n">_</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">trim</span><span class="p">().</span><span class="n">splitn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">parts</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">err_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Header field should have form </span><span class="se">\&quot;</span><span class="s">X: Y</span><span class="se">\&quot;</span><span class="s">. Got: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">err_msg</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">fields</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">to_owned</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Tak jak poprzednio, argumentem wejściowym jest <code>Lines</code>. Tym razem bez <code>mut</code>,
ponieważ nie będziemy zmieniać tego obiektu tak jak poprzednio przy pomocy
<code>next()</code>, tylko będziemy go sobie tylko "oglądać" przy pomocy innych metod).</p>
<p>Korzystamy z wbudowanej kolekcji <code>HashMap</code> aby przechowywać wartości pól.</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>Dla każdej linii (która nie jest pusta), sparsujemy ją i podzielimy na nazwę
pola i wartość.</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">lines</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">parts</span>: <span class="nb">Vec</span><span class="kp">&amp;</span><span class="nc">lt</span><span class="p">;</span><span class="n">_</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">trim</span><span class="p">().</span><span class="n">splitn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">parts</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">err_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Header field should have form </span><span class="se">\&quot;</span><span class="s">X: Y</span><span class="se">\&quot;</span><span class="s">. Got: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">err_msg</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">fields</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">to_owned</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p><code>filter</code> jest metodą cechy <code>Iterator</code>, która przyjmuje predykat i zwraca
iterator, który ignoruje elementy nie spełniającego tego predykatu. W tym
przypadku, interesują nas tylko niepuste linie. Na każdej linii wykonujemy
znajomy nam <code>trim()</code>, a następnie dzielimy ją na co najwyżej dwie części (licząc
od lewej) przy napotkaniu ": ". Każde poprawnie sparsowane pole zapisujemy w
słowniku (<code>HashMap</code>) metodą <code>insert()</code> (pamiętając o zamianie <code>&amp;str</code> na <code>String</code>
przy pomocy <code>to_owned()</code>).</p>
<p>Na końcu zwracamy nasz słownik jako <code>Ok(fields)</code>.</p>
<h4>Funkcje anonimowe (closures)</h4>
<p>Jak w większości współczesnych języków programowania, w Ruscie można korzystać z
funkcji anonimowych. Ich składnia jest następująca:</p>
<div class="highlight"><pre><span></span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
</pre></div>


<p>W przykładzie z poprzedniego akapitu skorzystaliśmy z nich do odsiania pustych
linii.</p>
<h3><code>ResponseHeader</code></h3>
<p>Implementacja <code>ResponseHeader</code> wygląda bardzo podobnie, zarówno w kwestii
definicji struktury jak i parsowania, dlatego nie będę poświęcał jej zbyt wiele
czasu. Jedyną interesującą częścią, może być zamiana napisu zawierającego liczbę
na zmienną typu całkowitoliczbowego.</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">status_code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">status_code</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">parse</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                 </span><span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Status code cannot be parsed. Got: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">status_code</span><span class="p">))</span><span class="w"></span>
<span class="w">             </span><span class="p">})</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>Zmienna <code>status_code</code> jest później zapisywana do pola o typie <code>u16</code>, więc
kompilator wie, której wersji metody <code>parse()</code> musi tutaj użyć. W przypadku
niepowodzenia, błąd zwracany przez <code>parse()</code> będzie jednak typu innego niż
<code>io::Result</code>, który zwracamy w metodzie <code>ResponseHeader::parse()</code>. W związku z
tym, trzeba przerobić jeden rodzaj błędu na drugi.</p>
<p>W poprzednim poście wspominałem jak można to robić, w tym wypadku jednak,
sytuacja jest jednorazowa, a dodatkowo chcemy dodać nieco więcej informacji o
tym, kiedy błąd nastąpił. W takich przypadkach przydaje się metoda <code>map_err()</code>,
która przyjmuje funkcję mającą za zadanie skonwertować jeden typ błędu na inny.</p>
<h2>Zapisywanie do obiektów z cechą <code>Writer</code></h2>
<p>Obiekty implementujące cechę <code>Writer</code> udostępniają m.in. metodę <code>write_all()</code>,
która przyjmuje wycinek tablicy (slice) bajtów (<code>u8</code>), aby ją zapisać. Pewnym
przykrym skutkiem ubocznym takiego interfejsu jest to, że cały obiekt trzeba
zakodować w formie <code>&amp;[u8]</code> zanim przekaże się go pisarzowi. W przypadku
nagłówków HTTP, nie byłby to zapewne zbyt kosztowny proces, ale skoro możemy
zrobić to wydajniej, to czemu nie spróbować?</p>
<p>Jednym ze wzorców, które znam z C++ (<code>operator&lt;&lt;</code>) czy Go, jest implementowanie
przez obiekty przeznaczone do zapisu metody (nazwijmy ją <code>write_to</code>), która
przyjmuje <code>Writer</code>. Najczęściej ich implementacje nie budują całego obiektu jako
spójny ciąg bajtów, tylko zapisują go po kawałku. Zastanawiałem się, czy Rust
oferuje jakieś inne rozwiązania lub gotowe cechy, które tylko trzeba
zaimplementować. Zapytałem na kanale IRC <strong>#rust-beginners</strong> i okazało się, że
nie ma niczego podobnego w bibliotece standardowej i metoda taka jak:</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">write_to</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">w</span>: <span class="kp">&amp;</span><span class="nc">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;()</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>wydaje się dobrym pomysłem.</p>
<p>W związku z tym, stworzymy sobie nowy plik <code>write_to.rs</code> w głównym katalogu
(<code>src</code>). A w <code>main.rs</code> dodamy linijkę <code>mod write_to;</code>.</p>
<p><code>write_to.rs</code> zawierać będzie definicję cechy:</p>
<div class="highlight"><pre><span></span><span class="c1">// write_to.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Write</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">WriteTo</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">write_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">w</span>: <span class="kp">&amp;</span><span class="nc">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;()</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<h3><code>HttpStream::send()</code></h3>
<p>Mając zaimplementowaną cechę <code>WriteTo</code> dla <code>Response</code> i <code>Request</code>,
implementacja <code>send()</code> stanie się trywialna:</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HttpStream</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="na">&#39;a</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="n">tcp_writer</span>: <span class="nc">BufWriter</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">net</span>::<span class="n">TcpStream</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="na">&#39;a</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">HttpStream</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="na">&#39;a</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">send</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">WT</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">packet</span>: <span class="kp">&amp;</span><span class="nc">amp</span><span class="p">;</span><span class="n">WT</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;()</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">WT</span>: <span class="nc">WriteTo</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">BufWriter</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">net</span>::<span class="n">TcpStream</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">packet</span><span class="p">.</span><span class="n">write_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tcp_writer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">tcp_writer</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p><code>where</code> użyte jest tutaj dla wygody, aby nie zaciemniać deklaracji <code>send</code>.
Zamiast tego, można by po prostu napisać:</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">send</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">WT</span>: <span class="nc">WriteTo</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">BufWriter</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">net</span>::<span class="n">TcpStream</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">packet</span>: <span class="kp">&amp;</span><span class="nc">amp</span><span class="p">;</span><span class="n">WT</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;()</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">packet</span><span class="p">.</span><span class="n">write_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tcp_writer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">tcp_writer</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>ale wygląda to bardzo nieczytelnie.</p>
<p>Notacja <code>X: Y</code> oznacza w tym wypadku "typ X implementujący cechę Y". Na potrzeby
<code>send</code> oczekujemy, że <code>WT</code> będzie potrafiło zapisać się do <code>BufWriter</code>
opakowującego <code>TcpStream</code>.</p>
<h3>Implementacja cechy <code>WriteTo</code></h3>
<h4><code>Request</code></h4>
<div class="highlight"><pre><span></span><span class="k">impl</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">WriteTo</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">W</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Request</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">write_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">w</span>: <span class="kp">&amp;</span><span class="nc">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;()</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">write_to</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">by_ref</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">w</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">body</span><span class="p">.</span><span class="n">as_slice</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>W tej chwili wydaje mi się, że rozumiem konieczność użycia <code>by_ref()</code> (udało mi
się zaimplementować tę cechę bez użycia tej metody), ale nie chciałbym teraz o
tym opowiadać, dopóki nie będę w 100% pewien.  Prawdopodobnie będzie to materiał
na jeden z kolejnych postów.</p>
<h4><code>RequestHeader</code></h4>
<div class="highlight"><pre><span></span><span class="k">impl</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">WriteTo</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">W</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">RequestHeader</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">write_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">w</span>: <span class="kp">&amp;</span><span class="nc">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="w"> </span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;()</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="s">&quot;{method} {uri} {protocol}</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">method</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">uri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">uri</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">protocol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">protocol</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fields</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;{}: {}</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="o">?</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p><code>write!</code> jest makrem podobnym do <code>println!</code>, które przyjmuje jako jeden ze
swoich argumentów format string, tyle tylko, że dodatkowo jako pierwszy argument
podajemy <code>Writer</code>. Po zapisaniu pierwszej linii (np. "GET /index.html
HTTP/1.1\r\n"), iteruję po polach nagłówka i zapisuje każde z nich w nowej
linii.</p>
<h2>Odesłanie pakietu</h2>
<div class="highlight"><pre><span></span><span class="c1">// main.rs</span>
<span class="c1">// ...</span>

<span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp</span>: <span class="nc">net</span>::<span class="n">TcpStream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">http</span>::<span class="n">HttpStream</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">tcp</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="n">h</span><span class="p">.</span><span class="n">is_closed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">h</span><span class="p">.</span><span class="n">get_request</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;UnexpectedEOF&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">response_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">request</span><span class="p">.</span><span class="n">write_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="k">mut</span><span class="w"> </span><span class="n">response_body</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">fields</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;Content-Length&quot;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"> </span><span class="n">response_body</span><span class="p">.</span><span class="n">len</span><span class="p">().</span><span class="n">to_string</span><span class="p">());</span><span class="w"></span>

<span class="w">        </span><span class="n">h</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">http</span>::<span class="n">Response</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                   </span><span class="n">header</span>: <span class="nc">http</span>::<span class="n">ResponseHeader</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                       </span><span class="n">fields</span>: <span class="nc">fields</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">protocol</span>: <span class="nc">request</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">protocol</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"></span>
<span class="w">                       </span><span class="n">status_code</span>: <span class="mi">200</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">status_desc</span>: <span class="s">&quot;OK&quot;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"></span>
<span class="w">                   </span><span class="p">},</span><span class="w"></span>
<span class="w">                   </span><span class="n">body</span>: <span class="nc">response_body</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Budujemy <code>http:Response</code> ustawiając status na <code>200 OK</code>, kopiujemy wersję
protokołu z żądania, oraz zapisujemy całe (łącznie z nagłówkiem) żądanie w
<code>response_body</code>, pamiętając o ustawieniu pola <code>Content-Length</code> w nagłówku.</p>
<h2>Podsumowanie</h2>
<p>Uff! Ten post był wyjątkowo długi i napisanie go zajęło mi naprawdę dużo czasu.
Mam nadzieję, że poprzedni post (część 5) wyjaśnił trochę, co znaczą te
wszechobecne '?' i kod z tego wpisu jest nieco łatwiejszy do zrozumienia.</p>
<p>W kolejnym poście dodamy lepszą obsługę błędów (w tej chwili trudno jest
przetestować nasze proxy, ponieważ wysyłanie dowolnego innego zapytania niż
"GET" powoduje zakończenie pracy programu) i być może uprościmy korzystanie z
<code>http::Response</code> i <code>http::Request</code> (np. eliminując potrzebę ustawiania
<code>Content-Length</code> ręcznie).</p>
<h1>Pozostałe części</h1>
<ul>
<li>następny post (część 7) w przygotowaniu</li>
<li><a href="serwer-proxy-w-ruscie-czesc-5.html">poprzedni post (część 5) (obsługa błędów, makra)</a></li>
</ul>
    </article>

    <hr>
        <div class="comments">
            <div id="disqus_thread"></div>
            <script>
                var disqus_config = function () {
                    this.page.url = 'http://kele.github.io/' + 'serwer-proxy-w-ruscie-czesc-6-pl.html';
                    this.page.identifier = 'disqus-' + 'serwer-proxy-w-ruscie-czesc-6-pl.html';
                };
                (function() {  // DON'T EDIT BELOW THIS LINE
                    var d = document, s = d.createElement('script');
                    s.src = 'https://kele-github-io.disqus.com/embed.js';
                    s.setAttribute('data-timestamp', +new Date());
                    (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
        </div>
            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="./theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="./theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="./theme/js/clean-blog.min.js"></script>


</body>

</html>