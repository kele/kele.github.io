<!DOCTYPE html>
<html lang="pl">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">


        <title>Proxy server in Rust (part 4)</title>

            <link href="http://kele.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="kele.github.io Full Atom Feed" />
            <link href="http://kele.github.io/feeds/rust.atom.xml" type="application/atom+xml" rel="alternate" title="kele.github.io Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="../theme/css/bootstrap.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="../theme/css/clean-blog.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="../theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="rust" />
        <meta name="tags" contents="foxy" />


	                <meta property="og:locale" content="pl_PL.utf8">
		<meta property="og:site_name" content="kele.github.io">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="../drafts/proxy-server-in-rust-part-4-en.html">
	<meta property="og:title" content="Proxy server in Rust (part 4)">
	<meta property="og:description" content="">
	<meta property="og:image" content="../">
	<meta property="article:published_time" content="2017-06-20 00:00:00+02:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="../">kele.github.io</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">

                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('../theme/images/header.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Proxy server in Rust (part 4)</h1>
                        <span class="meta">wto 20 czerwiec 2017</span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p>Code available <a href="https://github.com/kele/foxy/tree/part4">here</a>.</p>
<h2>API design - continued</h2>
<h3>Old definition of <code>HttpPacket</code></h3>
<p>In the previous post we've drafted the <code>HttpStream</code> interface. It had <code>get</code> and
<code>send</code> methods receiving a <code>HttpPacket</code>.</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HttpPacket</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>


<p>If you know anything about HTTP you probably know that the packets can be
classified as requests or responses.</p>
<h4>Example request</h4>
<div class="highlight"><pre><span></span><span class="nf">GET</span> <span class="nn">/hello.htm</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">User-Agent</span><span class="o">:</span> <span class="l">Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span>
<span class="na">Host</span><span class="o">:</span> <span class="l">www.tutorialspoint.com</span>
<span class="na">Accept-Language</span><span class="o">:</span> <span class="l">en-us</span>
<span class="na">Accept-Encoding</span><span class="o">:</span> <span class="l">gzip, deflate</span>
<span class="na">Connection</span><span class="o">:</span> <span class="l">Keep-Alive</span>
</pre></div>


<h4>Example response</h4>
<div class="highlight"><pre><span></span><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Date</span><span class="o">:</span> <span class="l">Mon, 27 Jul 2009 12:28:53 GMT</span>
<span class="na">Server</span><span class="o">:</span> <span class="l">Apache/2.2.14 (Win32)</span>
<span class="na">Last-Modified</span><span class="o">:</span> <span class="l">Wed, 22 Jul 2009 19:15:56 GMT</span>
<span class="na">Content-Length</span><span class="o">:</span> <span class="l">88</span>
<span class="na">Content-Type</span><span class="o">:</span> <span class="l">text/html</span>
<span class="na">Connection</span><span class="o">:</span> <span class="l">Closed</span>

<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello, World!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>


<h3><code>get</code> -&gt; <code>get_request</code></h3>
<p>We're going to use separate receiving methods for requests and responses because
their structure is different and they are parsed in a different way.</p>
<h3><code>HttpRequest</code> and <code>HttpResponse</code> instead of <code>HttpPacket</code></h3>
<p>For now we're just going to store the content of the packets in
<code>string::String</code>. Gradually we're going to make the information more and more
structured (storing the status code, request method, URI, etc. separately).</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>
<span class="c1">// ...</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HttpRequest</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data</span>: <span class="nc">string</span>::<span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HttpResponse</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data</span>: <span class="nc">string</span>::<span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<h3><code>get_request</code> implementation</h3>
<p>The HTTP header ends with <span style="text-decoration: line-through">two
newlines</span> (actually, this is not true, see the next post in the series),
so we'd probably like to read the data from the socket byte per byte until we
encounter the ending sequence. We can use the <code>std::io::Bytes</code> type for that. It
is just an iterator over bytes for objects that implement the <code>std::io::Read</code>
trait.</p>
<p><code>std::net::TcpStream</code> satisfies the <code>Read</code> trait, but if we wanted to read from
it one byte at a time, each <code>read()</code> invocation would result in a system call,
degrading the performance significantly. Luckily even the Rust standard library
documentation mentions this problem and offers an elegant solution in the form
of <code>std::io::BufReader</code>. This type wraps a given <code>Read</code> object and buffers the
I/O operations minimizing the number of system calls. We can make use of it to
read from the socket one byte a time without degrading the performance.</p>
<p>As I already mentioned, <code>Bytes</code> is an iterator so to take the next element we're
using the <code>next()</code> method:</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>
<span class="c1">// ...</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_request</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">HttpRequest</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tcp_bytes</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">char</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>To cast the value from byte (<code>u8</code>) to <code>char</code> we're using the <code>as</code> keyword. What
the <code>unwrap()</code> is for? This method is implemented for <code>Result</code> and <code>Option</code>
types, amongst the others. A <code>Result</code> object can hold an <code>Ok</code> value or an <code>Err</code>
error. <code>Option</code> can be one of <code>Some</code> (value) or <code>None</code> (nothing). The <code>unwrap()</code>
method for both these types provides more or less the same functionality:</p>
<ul>
<li>if the object represents a value (<code>Ok</code> or <code>Some</code>) - return it</li>
<li>if it's not a value (<code>Err</code> or <code>None</code>), execute <code>panic!</code> (which is equivalent
  with terminating the program at this point)</li>
</ul>
<p>For this instance of the <code>Bytes</code> iterator, <code>next()</code> returns
<code>Option&lt;Result&lt;u8&gt;&gt;</code>. If there is no more data, <code>None</code> is returned. Otherwise,
<code>Some(x)</code> is returned where <code>x</code> is whatever the result of <code>read()</code> was (<code>Ok(b)</code>
with a single byte inside or <code>Err(e)</code> with an error). That's why we need two
<code>unwrap()</code> calls (one for <code>Option</code>, one for <code>Result</code>).</p>
<p>The full <code>get_request</code> implementation:</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>
<span class="c1">// ...</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_request</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">HttpRequest</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// TODO: error handling</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">lastChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">packet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">string</span>::<span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">tcp_bytes</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">char</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">packet</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">lastChar</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">lastChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">HttpRequest</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="nc">packet</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Right now in case of any error we're just going to terminate the program (what
<code>unwrap()</code> does).</p>
<p>The <code>get_request</code> method is using <code>self.tcp_bytes</code>. Previously <code>HttpStream</code>
consisted of only one field <code>tcp</code> of type <code>net::TcpStream</code>. Now, we're going to
have a new field of type <code>io::Bytes&lt;io::BufReader&lt;net::TcpStream&gt;&gt;</code> (iterator
over bytes read from <code>TcpStream</code> with buffering). Unfortunately, the <code>BufReader</code>
takes ownership of the <code>TcpStream</code> but it doesn't provide any methods to write
to the stream! We definitely don't want that. This is a good moment to talk
about sharing.</p>
<h3>Sharing</h3>
<p><a name="backref-1"></a>
Sharing in languages with garbage collecting is pretty easy, because the
programmer doesn't have to worry about memory management. In languages like C++
one can use references or smart pointers (i.e. <code>std::shared_ptr</code>). All these
solutions have some drawbacks:</p>
<ul>
<li>garbage collecting causes degraded performance <strong>and</strong> really poor guarantees
  about the time when the resources will be freed</li>
<li><code>std::shared_ptr</code> and similar types are based on reference counting which also
  comes with some runtime overhead (also, whatever is wrapped in <code>shared_ptr</code>
  has to be allocated on the heap<sup><a href="#shared-ptr">1</a></sup>),</li>
<li>references <strong>are not safe</strong> (<a href="https://en.wikipedia.org/wiki/Dangling_pointer">dangling
  reference problem</a>).</li>
</ul>
<p>Rust is designed with performance and memory safety in mind. We could use the
<code>alloc::rc::Rc</code> type if we wanted to rely on reference counting, but we wouldn't
gain much here over C++.</p>
<p><a name="backref-2"></a>
We are going to references instead. References in Rust are different than what
we know from C++, though. To use them, the Rust compiler needs to know how long
the objects they point to are going to live and if it sees something shady, a
compiler error is produced.</p>
<h3>Lifetimes</h3>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>
<span class="c1">// ...</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HttpStream</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tcp</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">net</span>::<span class="n">TcpStream</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">tcp_bytes</span>: <span class="nc">io</span>::<span class="n">Bytes</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">BufReader</span><span class="o">&lt;&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">net</span>::<span class="n">TcpStream</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">HttpStream</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">tcp</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">net</span>::<span class="n">TcpStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">HttpStream</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">HttpStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">tcp</span>: <span class="nc">tcp</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">tcp_bytes</span>: <span class="nc">io</span>::<span class="n">BufReader</span>::<span class="n">new</span><span class="p">(</span><span class="n">tcp</span><span class="p">).</span><span class="n">bytes</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Whenever we see a name starting with <code>'</code> in Rust, like <code>'a</code> or <code>'static</code>, this
means we're dealing with a <strong>lifetime</strong>. In the code above we're telling the
compiler that:</p>
<ul>
<li>one of the parameters of <code>HttpStream</code> is a lifetime (let's call it <code>'a</code>
  internally)</li>
<li><code>tcp</code> is a reference for a <code>net::TcpStream</code> object that has lifetime <code>'a</code></li>
<li><code>tcp_bytes</code> is a <code>Bytes</code> iterator over buffered <code>Reader</code>, the <code>Reader</code> itself
  is a reference to <code>net::TcpStream</code> object with lifetime <code>'a</code></li>
</ul>
<p>What did we gain by adding a few <code>'a</code> here and there? The compiler knows that
both fields refer to objects with the same lifetime and it can check when using
<code>HttpStream</code> that they live longer than the structure itself. Therefore it is
guaranteed that <code>tcp</code> nor <code>tcp_bytes</code> will ever contain a <strong>dangling
reference</strong>. Memory safety at compile time - that's what we expect from Rust.</p>
<p>In reality, whenever we're using references we're also using lifetimes.
Fortunately, due to <strong>lifetime elision</strong> we don't need to specify the lifetimes
manually every time because in some cases the compiler can figure them out by
itself.</p>
<h3><code>send()</code></h3>
<p>Implementing <code>send()</code> without structuring the data is trivial:</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>
<span class="c1">// ...</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">resp</span>: <span class="kp">&amp;</span><span class="nc">HttpResponse</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// TODO: error handling</span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">tcp</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">resp</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_bytes</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<h3>Changes in the main loop</h3>
<p>We've replaced the <code>HttpPacket</code> with <code>HttpResponse</code> and <code>HttpRequest</code>. Also, the
<code>HttpStream</code> now receives the <code>TcpStream</code> by reference (the ownership is not
passed). Therefore, the main loop needs to look like this:</p>
<div class="highlight"><pre><span></span><span class="c1">// main.rs</span>
<span class="c1">// ...</span>

<span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp</span>: <span class="nc">net</span>::<span class="n">TcpStream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">http</span>::<span class="n">HttpStream</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="n">h</span><span class="p">.</span><span class="n">is_closed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">h</span><span class="p">.</span><span class="n">get_request</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Error while getting http request: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="n">h</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">http</span>::<span class="n">HttpResponse</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="nc">request</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The <code>clone()</code> method copies the <code>String</code> object here.</p>
<h2>Summary</h2>
<p>We've managed to write simple implementations of <code>get_request()</code> and <code>send()</code>
methods. One can test the program with a simple shell command:</p>
<div class="highlight"><pre><span></span>cat request.txt <span class="p">|</span> netcat <span class="m">127</span>.0.0.1 <span class="m">4000</span>
</pre></div>


<p>The <code>request.txt</code> file can contain any data that ends with two newlines.
The contents of the file before the ending sequence should be echoed back.</p>
<p>In the next parts we are going to talk error handling (<code>unwrap()</code> should not
pass the code review here) and the contents of HTTP packets.</p>
<h1>Other parts</h1>
<ul>
<li>next post (part 5) - work in progress</li>
<li><a href="proxy-server-in-rust-part-3.html">previous post (part 3)</a></li>
</ul>
<h3>Footnotes</h3>
<p><a name="shared-ptr"></a><sup>1</sup> It is possible to point <code>shared_ptr</code> to
memory on the stack or even different resources than memory, but doing it right
requires great C++ expertise. Even then it's not the safest option.(<a href="#backref-1">back to
text</a>)</p>
    </article>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="../theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="../theme/js/clean-blog.min.js"></script>


</body>

</html>