<!DOCTYPE html>
<html lang="pl">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">


        <title>Proxy server in Rust (part 3)</title>

            <link href="http://kele.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="kele.github.io Full Atom Feed" />
            <link href="http://kele.github.io/feeds/rust.atom.xml" type="application/atom+xml" rel="alternate" title="kele.github.io Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="../theme/css/bootstrap.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="../theme/css/clean-blog.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="../theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="rust" />
        <meta name="tags" contents="foxy" />


	                <meta property="og:locale" content="pl_PL.utf8">
		<meta property="og:site_name" content="kele.github.io">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="../drafts/proxy-server-in-rust-part-3-en.html">
	<meta property="og:title" content="Proxy server in Rust (part 3)">
	<meta property="og:description" content="">
	<meta property="og:image" content="../">
	<meta property="article:published_time" content="2017-06-19 00:00:00+02:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="../">kele.github.io</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">

                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('../theme/images/header.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Proxy server in Rust (part 3)</h1>
                        <span class="meta">pon 19 czerwiec 2017</span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p>Code available <a href="https://github.com/kele/foxy/tree/part3">here</a>.</p>
<h2>HTTP protocol library</h2>
<p>There exists a pretty mature library for handling HTTP protocol for Rust already
- <a href="https://github.com/hyperium/hyper"><strong>hyper</strong></a>. Amongst the others it's used
by <a href="https://github.com/servo/servo"><strong>Servo</strong></a> - probably the most prominent
Rust project to date.</p>
<p>Nevertheless, I wouldn't learn much by just settling to use an external library,
so I'm going to write my own HTTP protocol handling module.</p>
<h2>Creating a new module</h2>
<p>Rust code is organized in <strong>crates</strong> which consist of <strong>modules</strong>. Crates
correspond to libraries known from other languages and modules to packages. Each
crate has it's <strong>root module</strong> which can have submodules as it's descendants.</p>
<p>To use a module we need to declare it first:</p>
<div class="highlight"><pre><span></span><span class="k">mod</span> <span class="nn">http</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p><a name="backref-1"></a>
Rust<sup><a href="#rust-i-cargo">1</a></sup> will then expect a <code>http.rs</code> or <code>http/mod.rs</code>
source file. In one of these places we're going to write our code for HTTP
handling.</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HttpStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The <code>struct</code> keyword is used to define new structures and <code>pub</code> is used for
making it externally visible (like <code>public</code> in C++ or Java).</p>
<h2>Designing the API and the ownership model</h2>
<p>We already know where we want to put our code so it seems like a good time to
start designing the API.</p>
<p>The main object will be <code>http::HttpStream</code> - a wrapper for <code>net::TcpStream</code> with
a few HTTP specific functionalities added. It is also going to <strong>own</strong> the
<code>TcpStream</code>. That being said, we need to talk a bit about the Rust ownership
model.</p>
<h2>Ownership and borrowing</h2>
<p>The ownership model is probably the most distinct feature of Rust amongst the
popular modern programming languages.</p>
<p>In Rust, an object can be passed to a function in three different ways:</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">{};</span><span class="w"></span>

<span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="n">xyz</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</pre></div>


<h3><code>foo(x)</code></h3>
<p>In this case <code>x</code> is passed to <code>foo()</code> <strong>by value</strong>. In Rust it means one of two
things:</p>
<ul>
<li><code>x</code> is going to be copied (if it implements the <code>Copy</code> trait, more on that
  later)</li>
<li><strong>the ownership of <code>x</code> is passed to <code>foo()</code></strong> (or, <code>x</code> is moved).</li>
</ul>
<p>In the second case <code>x</code> cannot be used after the call to <code>foo()</code>!. For example: </p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="w"> </span>:<span class="nc">X</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// WRONG</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>trying to compile the above code will result in an error:</p>
<div class="highlight"><pre><span></span>error[E0382]: use of moved value: `x`
 --&gt; &lt;anon&gt;:7:9
  |
  |     foo(x);
  |         - value moved here
  |     foo(x);
  |         ^ value used here after move
  |
  = note: move occurs because `x` has type `X`, which does not implement the `Copy` trait

error: aborting due to previous error
</pre></div>


<p>After <code>x</code> is moved to <code>foo()</code> we no longer have access to it. This semantics
allows the compiler to do following things:</p>
<ul>
<li>forbid using <code>x</code> after it was moved,</li>
<li>accurately decide which piece of code is responsible for freeing the memory
  belonging to <code>x</code> (in this case, <code>foo</code> is).</li>
</ul>
<p>This is how Rust can achieve memory safety with no runtime overhead (no
reference counting, no garbage collecting).</p>
<h3><code>bar(&amp;x)</code></h3>
<p><code>&amp;x</code> in Rust indicates a <strong>borrow</strong>. After <code>bar()</code> finishes it's work it has to
give <code>x</code> back in an untouched state. This means that <code>x</code> is lended to <code>bar()</code> in
a <strong>read only</strong> way.</p>
<p>This allows us to safely write code such as:</p>
<div class="highlight"><pre><span></span><span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>because after every <code>bar(&amp;x)</code> call we're getting <code>x</code> back. The compiler then
knows that:</p>
<ul>
<li><code>bar</code> doesn't have to free the memory of <code>x</code>,</li>
<li><code>bar</code> cannot keep <code>x</code> forever (what does this actually mean is a more
  complicated topic and we're going to cover it when discussing <strong>lifetimes</strong>).</li>
</ul>
<h3><code>xyz(&amp;mut x)</code></h3>
<p>Similarly to <code>&amp;x</code>, but this time we're lending the object with permission to
change it. Without discussing <strong>lifetimes</strong> we cannot really talk more about the
differences between <code>&amp;</code> and <code>&amp;mut</code>, please be patient. :)</p>
<h2>Designing the API (continued)</h2>
<p>Knowing how Rust handles argument passing we can start thinking about using the
new <code>HttpStream</code> object. At first, we're going to write an <strong>echo server</strong>,
which means that we're going to send back whatever we've received.</p>
<div class="highlight"><pre><span></span><span class="c1">// main.rs</span>

<span class="c1">// ...</span>

<span class="k">mod</span> <span class="nn">http</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp</span>: <span class="nc">net</span>::<span class="n">TcpStream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">http</span>::<span class="n">HttpStream</span>::<span class="n">new</span><span class="p">(</span><span class="n">tcp</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ... main loop here ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>We are going to move the TCP socket to a new <code>HttpStream</code> object. The
definition of <code>HttpStream</code> looks as follows:</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HttpStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tcp</span>: <span class="nc">net</span>::<span class="n">TcpStream</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">HttpStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">tcp</span>: <span class="nc">net</span>::<span class="n">TcpStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">HttpStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">HttpStream</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">tcp</span>: <span class="nc">tcp</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p><code>impl</code> is used for implementing methods for a given structure. As one can see,
<code>pub</code> is used on method granularity in Rust. In this case, <code>new</code> is an
<strong>associated function</strong> (in other languages that would be called a static
method), which means that it does not need to receive the object of the type
it's associated with but it still has access to the private fields and methods
of this type. This is why it's called as <code>HttpStream::new()</code> and not <code>h.new()</code>.</p>
<p>The only duty of <code>new</code> is to pass <code>tcp</code> to <code>HttpStream</code>, because we don't really
want <code>tcp</code> to be a public field.</p>
<div class="highlight"><pre><span></span><span class="c1">// main.rs</span>

<span class="c1">// ...</span>

<span class="k">mod</span> <span class="nn">http</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp</span>: <span class="nc">net</span>::<span class="n">TcpStream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">http</span>::<span class="n">HttpStream</span>::<span class="n">new</span><span class="p">{</span><span class="n">tcp</span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="n">h</span><span class="p">.</span><span class="n">is_closed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">h</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Error while getting http request: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>There are two new methods here: <code>is_closed()</code> and <code>get()</code>.</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>

<span class="c1">// ...</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">HttpStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">HttpPacket</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TODO</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">HttpPacket</span><span class="w"> </span><span class="p">{})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_closed</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TODO</span>
<span class="w">        </span><span class="kc">false</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p><a name="backref-2"></a>
<code>get</code> will be used for receiving HTTP packets, so it needs to:</p>
<ul>
<li>have <span style="text-decoration:
  line-through">mutable</span><sup><a href="#mutable-tcp">2</a></sup>  access to the <code>tcp</code>
  field through <code>self</code> (like in Python, or <code>this</code> in C++)</li>
<li>return <code>io::Result&lt;HttpPacket&gt;</code> because as <a href="proxy-server-in-rust-part-2.html">I mentioned
  earlier</a>, something may go wrong while
  receiving the packet and we would like to handle the error.</li>
</ul>
<p>Right now the it's a dummy implementation so it just returns an empty packet
(wrapper with <code>Ok</code>).</p>
<p><code>is_closed()</code> is a predicate that tells us whether the connection is closed or
not.</p>
<p>We need a new <code>HttpPacket</code> structure representing an HTTP packet.</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>

<span class="c1">// ...</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HttpPacket</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>


<p>One more thing to do in the main loop is to send back the packet.</p>
<div class="highlight"><pre><span></span><span class="c1">// main.rs</span>

<span class="c1">// ...</span>

<span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp</span>: <span class="nc">net</span>::<span class="n">TcpStream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">http</span>::<span class="n">HttpStream</span>::<span class="n">new</span><span class="p">{</span><span class="n">tcp</span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="n">h</span><span class="p">.</span><span class="n">is_closed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">h</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Error while getting http request: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="n">h</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">http</span>::<span class="n">HttpPacket</span><span class="p">{});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>And here's a dummy implementationof <code>send</code>:</p>
<div class="highlight"><pre><span></span><span class="c1">// http/mod.rs</span>

<span class="c1">// ...</span>

<span class="k">impl</span><span class="w"> </span><span class="n">HttpStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">packet</span>: <span class="kp">&amp;</span><span class="nc">HttpPacket</span><span class="p">)</span><span class="w"> </span><span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Here, <code>send</code> might return an error but if everything goes smoothly there's
nothing to return. In this case, the <code>()</code> (unit) type is used (which
corresponds to <code>void</code> known from other languages).</p>
<h2>Summary</h2>
<p>We didn't manage to write any working code (at least it compiles!) but we've
talked about some key features of Rust. Without discussing them it wouldn't be
possible to understand any meaningful code.</p>
<p>In the next post I hope to implement a simple echo server.</p>
<h1>Other parts</h1>
<ul>
<li><a href="proxy-server-in-rust-part-4.html">next post (part 4)</a></li>
<li><a href="proxy-server-in-rust-2.html">previous post (part 2)</a></li>
</ul>
<hr>

<h3>Footnotes</h3>
<p><a name="rust-i-cargo"></a><sup>1</sup> In the official docs "Rust" is used as
both the language itself and <code>cargo</code>.  (<a href="#backref-1">go back</a>)
<a name="mutable-tcp"></a><sup>2</sup> This is a late translation of a post in
Polish, so I already know that the <code>read()</code> method is also implemented for <code>&amp;'a
net::TcpStream</code> - no mutability needed here. (<a href="#backref-2">go back</a>)</p>
    </article>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="../theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="../theme/js/clean-blog.min.js"></script>


</body>

</html>